"""Developments API - 開発進捗管理"""

from fastapi import APIRouter, HTTPException, BackgroundTasks
from fastapi.responses import StreamingResponse
from typing import List, Optional
from datetime import datetime
import uuid
import asyncio
import io
import zipfile
from pydantic import BaseModel

from app.models.development import Development, DevelopmentStatus, AgentLogEntry
from app.services.database import db
from app.services.github_service import github_service
from app.agents.tech_lead import TechLeadAgent
from app.agents.coder import CoderAgent
from app.agents.tester import TesterAgent

router = APIRouter()


class StartDevelopmentRequest(BaseModel):
    requirement_id: str
    project_id: str = "default"


@router.get("/", response_model=List[Development])
async def list_developments(
    project_id: str = "default",
    status: Optional[DevelopmentStatus] = None,
):
    """開発進捗一覧を取得"""
    devs_data = await db.list_developments(
        project_id=project_id,
        status=status.value if status else None,
    )
    devs = [Development(**d) for d in devs_data]
    return sorted(devs, key=lambda x: x.created_at, reverse=True)


@router.get("/{development_id}", response_model=Development)
async def get_development(development_id: str):
    """開発進捗詳細を取得"""
    dev_data = await db.get_development(development_id)
    if not dev_data:
        raise HTTPException(status_code=404, detail="Development not found")
    return Development(**dev_data)


@router.get("/{development_id}/logs", response_model=List[AgentLogEntry])
async def get_agent_logs(development_id: str):
    """エージェント動作ログを取得"""
    dev_data = await db.get_development(development_id)
    if not dev_data:
        raise HTTPException(status_code=404, detail="Development not found")
    dev = Development(**dev_data)
    return dev.agent_logs


@router.post("/start")
async def start_development(
    request: StartDevelopmentRequest,
    background_tasks: BackgroundTasks,
):
    """開発を開始"""
    development_id = str(uuid.uuid4())

    development = Development(
        id=development_id,
        project_id=request.project_id,
        requirement_id=request.requirement_id,
        status=DevelopmentStatus.DESIGNING,
        agent_logs=[
            AgentLogEntry(
                timestamp=datetime.now(),
                agent="system",
                message="開発プロセスを開始しました",
            )
        ],
    )
    await db.create_development(development)

    # バックグラウンドで開発プロセスを実行
    background_tasks.add_task(
        _run_development_pipeline,
        development_id=development_id,
    )

    return {
        "status": "started",
        "development_id": development_id,
        "message": "開発プロセスを開始しました",
    }


@router.get("/github/status")
async def get_github_status():
    """GitHub連携の設定状況を取得"""
    return {
        "configured": github_service.is_configured(),
        "repo": github_service.repo_name if github_service.is_configured() else None,
    }


@router.post("/{development_id}/create-pr")
async def create_pull_request(development_id: str):
    """生成されたコードをGitHubにプッシュしてPRを作成"""
    dev_data = await db.get_development(development_id)
    if not dev_data:
        raise HTTPException(status_code=404, detail="Development not found")

    # GitHub連携が設定されていない場合
    if not github_service.is_configured():
        raise HTTPException(
            status_code=400,
            detail="GitHub連携が設定されていません。.envファイルでGITHUB_TOKENとGITHUB_REPOを設定してください。"
        )

    dev = Development(**dev_data)

    # 生成ファイルがない場合
    if not dev.generated_files:
        raise HTTPException(status_code=400, detail="生成されたファイルがありません")

    # ステータスがreview以外の場合
    if dev.status not in [DevelopmentStatus.REVIEW, DevelopmentStatus.MERGED]:
        raise HTTPException(status_code=400, detail="開発が完了していません")

    # 要件定義を取得してタイトルを取得
    req_data = await db.get_requirement(dev.requirement_id)
    req_title = req_data.get("title", "Auto-generated code") if req_data else "Auto-generated code"

    # ブランチ名を生成
    branch_name = f"auto-dev/{development_id[:8]}"

    try:
        # コードをプッシュ
        files = [
            {"path": f.path, "content": f.content}
            for f in dev.generated_files
        ]
        push_result = github_service.push_generated_code(
            files=files,
            branch_name=branch_name,
            commit_message=f"feat: {req_title}",
        )

        # PRを作成
        pr_body = f"""## 自動生成コード

このPRは Auto-Dev Department によって自動生成されました。

### 要件
{req_title}

### 生成ファイル
{chr(10).join([f'- `{f.path}`' for f in dev.generated_files])}

### 開発ID
`{development_id}`

---
> Generated by Auto-Dev Department
"""
        pr_result = github_service.create_pull_request(
            title=f"[Auto-Dev] {req_title}",
            body=pr_body,
            head_branch=branch_name,
        )

        # 開発情報を更新
        await db.update_development(development_id, {
            "github_branch": branch_name,
            "github_pr_id": pr_result["pr_number"],
            "github_pr_url": pr_result["pr_url"],
            "status": DevelopmentStatus.REVIEW.value,
            "updated_at": datetime.now(),
        })

        return {
            "status": "created",
            "branch": branch_name,
            "pr_url": pr_result["pr_url"],
            "pr_number": pr_result["pr_number"],
            "files_pushed": push_result["commits"],
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/{development_id}/download")
async def download_generated_code(development_id: str):
    """生成されたコードをZIPファイルでダウンロード"""
    dev_data = await db.get_development(development_id)
    if not dev_data:
        raise HTTPException(status_code=404, detail="Development not found")

    dev = Development(**dev_data)

    if not dev.generated_files:
        raise HTTPException(status_code=400, detail="生成されたファイルがありません")

    # ZIPファイルを作成
    zip_buffer = io.BytesIO()
    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
        for file in dev.generated_files:
            # ファイルパスとコンテンツを追加
            zip_file.writestr(file.path, file.content)

    zip_buffer.seek(0)

    # ファイル名を生成
    filename = f"auto-dev-{development_id[:8]}.zip"

    return StreamingResponse(
        zip_buffer,
        media_type="application/zip",
        headers={
            "Content-Disposition": f'attachment; filename="{filename}"'
        }
    )


async def _add_log(development_id: str, agent: str, message: str, level: str = "info"):
    """ログエントリを追加"""
    dev_data = await db.get_development(development_id)
    if dev_data:
        logs = dev_data.get("agent_logs", [])
        logs.append({
            "timestamp": datetime.now(),
            "agent": agent,
            "message": message,
            "level": level,
        })
        await db.update_development(development_id, {"agent_logs": logs})


async def _update_status(development_id: str, status: DevelopmentStatus):
    """ステータスを更新"""
    await db.update_development(development_id, {
        "status": status.value,
        "updated_at": datetime.now(),
    })


async def _run_development_pipeline(development_id: str):
    """開発パイプラインの実行"""
    try:
        # 開発情報を取得
        dev_data = await db.get_development(development_id)
        if not dev_data:
            return

        requirement_id = dev_data.get("requirement_id")

        # 要件定義を取得
        req_data = await db.get_requirement(requirement_id)
        if not req_data:
            await _add_log(development_id, "system", f"要件定義が見つかりません: {requirement_id}", "error")
            await _update_status(development_id, DevelopmentStatus.FAILED)
            return

        requirement_content = req_data.get("markdown_content", "")

        # Phase 1: Tech Lead - 設計
        await _add_log(development_id, "tech_lead", "設計を開始します...")
        await _update_status(development_id, DevelopmentStatus.DESIGNING)

        tech_lead = TechLeadAgent()
        design = await tech_lead.design(requirement_content)

        await _add_log(
            development_id,
            "tech_lead",
            f"設計完了: {len(design.get('file_structure', []))}ファイルを生成予定"
        )

        # 設計書を保存
        await db.update_development(development_id, {
            "design_doc": str(design),
            "updated_at": datetime.now(),
        })

        # Phase 2: Coder - 実装
        await _add_log(development_id, "coder", "コード生成を開始します...")
        await _update_status(development_id, DevelopmentStatus.CODING)

        coder = CoderAgent()
        files = await coder.generate_all(design)

        await _add_log(
            development_id,
            "coder",
            f"コード生成完了: {len(files)}ファイル"
        )

        # 生成ファイルを保存
        await db.update_development(development_id, {
            "generated_files": [f.model_dump() for f in files],
            "updated_at": datetime.now(),
        })

        # Phase 3: Tester - テスト
        await _add_log(development_id, "tester", "テストを実行します...")
        await _update_status(development_id, DevelopmentStatus.TESTING)

        tester = TesterAgent()
        all_passed = True
        test_results = []
        final_files = []

        for file in files:
            await _add_log(development_id, "tester", f"テスト中: {file.path}")
            fixed_file, passed, message = await tester.test_and_fix(file)
            final_files.append(fixed_file)
            test_results.append(f"{file.path}: {message}")

            if not passed:
                all_passed = False
                await _add_log(development_id, "tester", f"テスト失敗: {file.path} - {message}", "warning")

        # 最終結果を保存
        await db.update_development(development_id, {
            "generated_files": [f.model_dump() for f in final_files],
            "test_results": "\n".join(test_results),
            "updated_at": datetime.now(),
        })

        if all_passed:
            await _add_log(development_id, "system", "すべてのテストが成功しました")
            await _update_status(development_id, DevelopmentStatus.REVIEW)
        else:
            await _add_log(development_id, "system", "一部のテストが失敗しました", "warning")
            await _update_status(development_id, DevelopmentStatus.FAILED)

    except Exception as e:
        await _add_log(development_id, "system", f"エラーが発生しました: {str(e)}", "error")
        await _update_status(development_id, DevelopmentStatus.FAILED)
